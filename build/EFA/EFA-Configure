#!/bin/bash
# +--------------------------------------------------------------------+
# EFA-Configure
# Version 20140106
# +--------------------------------------------------------------------+
# Copyright (C) 2012~2014  http://www.efa-project.org
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# +--------------------------------------------------------------------+

# Enable Extended Globs
shopt -s extglob

# +---------------------------------------------------+
# Display menus
# +---------------------------------------------------+
show_menu() {
  menu=1
  while [ $menu == "1" ]
    do
      func_echo-header 
      echo -e "Please choose an option:"
      echo -e " "
      echo -e "0) Logout                              6) Greylisting"
      echo -e "1) Shell                               7) Auto Update" 
      echo -e "2) Reboot system                       8) Mail Settings" 
      echo -e "3) Halt system                         9) Spam Settings"
      echo -e "4) IP Settings                        10) Mysql Recovery" 
      echo -e "5) Tunables"
      echo -e -n "$green[EFA]$clean : "
      local choice
      read choice
      case $choice in
                    0) clear; SSHPID=`ps aux | egrep "sshd: [a-zA-Z]+@" | awk {' print $2 '}`; kill $SSHPID ;;
                    1) exit 0 ;;
                    2) func_reboot ;;
                    3) func_halt ;;
                    4) func_ip-settings ;;
                    5) func_tunables ;;
                    6) func_greylisting ;;
                    7) func_autoupdates ;;                    
                    8) func_mail-settings ;;
                    9) func_spam-settings ;;
                   10) func_recover-mysql ;;
                    *) echo -e "Error \"$choice\" is not an option..." && sleep 2
      esac
    done
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Configure Spam Behaviour
# +---------------------------------------------------+
function func_recover-mysql() {
  func_echo-header
  echo -e ""
  echo -e "MySQL Daemon and Database Recovery"
  echo -e ""
  echo -e "Description:"
  echo -e "This tool will assist with mysql recovery"
  echo -e "after a system crash or power failure."
  echo -e ""
  echo -e "If recovery fails, it is recommended that"
  echo -e "you restore your mysql database from a"
  echo -e "recent backup."
  echo -e ""
  echo -e -n "$green[EFA]$clean Do you wish to continue? (y/n): "
  read MYSQLQ
    
  flag=0
  while [ $flag == "0" ]
    do
      if [[ $MYSQLQ == "y" || $MYSQLQ == "Y" ]]; then
        # Fetch mysql pw
        MYSQLPW=`grep MYSQLROOTPWD /etc/EFA-Config | awk -F':' '{print $2}'` 

        echo -e ""
        echo -e "Beginning recovery..."

        echo -e ""
        echo -e "Stopping MySQL, MailScanner, and sqlgrey"
        service sqlgrey stop
        service MailScanner stop
        service mysqld stop
        #killall -9 mysqld

        echo -e "Removing socket if present"
        rm -f /var/lib/mysql/mysql.sock

        echo -e "Performing MyISAM checks"
        myisamchk --force --fast --update-state --key_buffer_size=64M --sort_buffer_size=64M --read_buffer_size=1M --write_buffer_size=1M /var/lib/mysql/*/*.MYI

        echo -e "Attempting to start MySQL"
        service mysqld start

        echo -e "Performing additional database checks"
        mysqlcheck -u sa -p$MYSQLPW --repair --all-databases
       
        echo -e "Runing database verification"
        mysqlcheck -u sa -p$MYSQLPW -o

        echo -e "Starting MySQL and MailScanner"
        service mysqld start
        service MailScanner start
        service sqlgrey start

        flag=1
      elif [[ $MYSQLQ == "n" || $MYSQLQ == "N" ]]; then
        echo -e ""
        echo -e "Exiting..."
        sleep 2
        flag=1
      else
        echo -e "Choice $green\"$MYSQLQ\"$clean is not a valid choice."
        echo -e ""
        echo -e -n "$green[EFA]$clean: "
        read MYSQLQ
      fi
    done
}
# +---------------------------------------------------+
# Configure Spam Behaviour
# +---------------------------------------------------+
function func_spam-settings() {
  menu=0
  spammenu=1
  while [ $spammenu == "1" ]
    do  
      func_echo-header
      echo -e "Mail settings"
      echo ""
      echo -e "1) Non Spam Settings"
      echo -e "2) Spam Settings"
      echo -e "3) Inline Signature Rules"
      echo -e ""
      echo -e "e) Return to main menu"
      echo -e ""
      echo -e -n "$green[EFA]$clean : "
      local choice
      read choice
      case $choice in
                1) func_ask-nonspam;;
                2) func_ask-spam;;
                3) func_ask-sigrules;;  
                e) menu=1 && return ;;
                *) echo -e "Error \"$choice\" is not an option..." && sleep 2
      esac
    done
}

# +---------------------------------------------------+
# Configure Spam Behaviour
# +---------------------------------------------------+
function func_ask-sigrules() {
  sigrules=0
  while [ $sigrules == "0" ]
  do
    func_echo-header
  
    echo -e ""
    echo -e "Description:"
    echo -e "Signature rules control which mail domains"
    echo -e "receive non spam inline signatures"
    echo -e "that allow users to submit spam."
    echo -e ""
  
    RULES=( `cat /etc/MailScanner/rules/sig.html.rules | sed '/^To:[[:space:]]\+default/d;/^$/d' | awk '{print $2}' | awk -F'@' '{print $2}'` )
  
    echo -e "Below is the list of current mail domains in the ruleset:"
    echo -e ""
    rLen=${#RULES[@]}
    for (( y=0; y<$rLen; y++ ));
      do
        echo -e "$((y+1))) ${RULES[$y]}"
      done
      echo -e ""
      echo -e "n) Add new mail domain rule"
      echo -e ""
      echo -e "e) Return to main menu"
      echo -e ""
      echo -e -n "$green[EFA]$clean : "
      local choice
      read choice
      case $choice in
             +([0-9]))
               if [[ $choice > "0" && $choice < $((rLen+1)) ]]; then
                 ENTDOMAIN=${RULES[$((choice-1))]}
                 echo -e "Entry Selected: $ENTDOMAIN" 
                 flag=0
                 while [ $flag == "0" ]
                   do
                     echo -e ""
                     echo -e "Do you want to $green[r]$clean replace, $green[d]$clean delete or $green[c]$clean cancel this entry? : "
                     local TMPOPTION
                     read TMPOPTION
                     if [[ $TMPOPTION == "r" || $TMPOPTION == "R" ]]; then
                        echo -e ""
                        echo -e "Please enter the domain you want use:"
                        echo -e -n "$green[Domain]$clean : "
                        local DOMAIN
                        read DOMAIN
                        echo -e "Thank you.."
                        sed -i "/^To:[[:space:]]\+\*\@$ENTDOMAIN/ c\To: *@$DOMAIN /etc/MailScanner/reports/en/inline.sig.in.html" /etc/MailScanner/rules/sig.html.rules
                        sed -i "/^To:[[:space:]]\+\*\@$ENTDOMAIN/ c\To: *@$DOMAIN /etc/MailScanner/reports/en/inline.sig.in.txt" /etc/MailScanner/rules/sig.text.rules
                        flag=1
                      elif [[ $TMPOPTION == "d" || $TMPOPTION == "D" ]]; then
                        sed -i "/^To:[[:space:]]\+\*\@$ENTDOMAIN/d" /etc/MailScanner/rules/sig.html.rules
                        sed -i "/^To:[[:space:]]\+\*\@$ENTDOMAIN/d" /etc/MailScanner/rules/sig.text.rules
                        echo -e "Entry deleted from signature rules." && sleep 2
                        flag=1
                      elif [[ $TMPOPTION == "c" || $TMPOPTION == "C" ]]; then
                        flag=1
                      else 
                        echo -e "Error \"$TMPOPTION\" is not an option..." && sleep 2
                      fi
                    done
                  else
                        echo -e "Error \"$choice\" is not an option..." && sleep 2
                  fi  
                    ;;
                n)  echo -e ""
                    echo -e "Please enter the domain you want add:"
                    echo -e -n "$green[Domain]$clean : "
                    local DOMAIN
                    read DOMAIN
                    echo -e "Thank you..."
                    echo -e ""
                    echo -e "To: *@$DOMAIN /etc/MailScanner/reports/en/inline.sig.in.html" >> /etc/MailScanner/rules/sig.html.rules
                    echo -e "To: *@$DOMAIN /etc/MailScanner/reports/en/inline.sig.in.txt" >> /etc/MailScanner/rules/sig.text.rules
                    echo -e "Domain $DOMAIN added to to signature rules"
                    pause
                    entry=1
                    ;;
                e)  spammenu=1 
                    service MailScanner reload
                    return
                    ;;
                *)  echo -e "Error \"$choice\" is not an option..." && sleep 2
                    echo -e -n "$green[EFA]$clean : "
                    ;;
          esac
  done
}
# +---------------------------------------------------+
# Configure Non Spam Behaviour
# +---------------------------------------------------+
function func_ask-nonspam() {
  func_echo-header

  echo -e ""
  echo -e "$green[EFA]$clean Non Spam Delivery and Retention Settings:"
  echo -e ""
  echo -e "$green[EFA]$clean By default, non spam is stored in the quarantine."
  echo -e "$green[EFA]$clean This allows a copy of each email to be retained"
  echo -e "$green[EFA]$clean for the retention period."
  echo -e ""
  echo -e "$green[EFA]$clean You can also choose to deliver non spam without"
  echo -e "$green[EFA]$clean storing it."
  echo -e ""
  echo -e -n "$green[EFA]$clean Do you want to $green DISABLE $clean storing non spam ? [y/N]: "

  read TMPSTORENSPAM
  STORENSPAM=""
  spamcheck=1
  while [ $spamcheck != "0" ]
    do 
      if [[ "$TMPSTORENSPAM" == "Y" || "$TMPSTORENSPAM" == "y" ]]; then 
        # Set non spam delivery behavior
        STORENSPAM="deliver header \"X-Spam-Status:No\""
        echo -e "$green[EFA]$clean Non spam storage $green DISABLED $clean"
        spamcheck=0
      elif [[ "$TMPSTORENSPAM" == "" || "$TMPSTORENSPAM" == "N" || "$TMPSTORENSPAM" == "n" ]]; then 
        STORENSPAM="store deliver header \"X-Spam-Status:No\""
        #sed -i '/Non Spam Actions =/ c\Non Spam Actions = store deliver header "X-Spam-Status:No custom(nonspam)"' /etc/MailScanner/MailScanner.conf
        echo -e "$green[EFA]$clean Non spam storage $green ENABLED $clean"
        spamcheck=0
      else
          echo -e "       $red ERROR: please make an selection.$clean"
          echo -e -n "$green[EFA]$clean Do you want to $green DISABLE $clean storing non spam ? [y/N]: "
          read TMPSTORENSPAM
      fi
  done

  echo -e ""
  echo -e "$green[EFA]$clean Non Spam Inline Signature Settings:"
  echo -e ""
  echo -e "$green[EFA]$clean By default, non spam has a signature appended."
  echo -e "$green[EFA]$clean This allows users to submit emails that they"
  echo -e "$green[EFA]$clean suspect is spam."
  echo -e ""
  echo -e "$green[EFA]$clean You can choose to disable the signature, especially"
  echo -e "$green[EFA]$clean if users are abusing this feature and poisoning the"
  echo -e "$green[EFA]$clean Bayesian filter."
  echo -e ""
  echo -e -n "$green[EFA]$clean Do you want to $green DISABLE $clean non spam signatures ? [y/N]: "

  read TMPNSPAMSIG
  NSPAMSIG=""
  spamcheck=1
  while [ $spamcheck != "0" ]
    do 
      if [[ "$TMPNSPAMSIG" == "Y" || "$TMPNSPAMSIG" == "y" ]]; then 
        # Set non spam delivery behavior
        NSPAMSIG=""
        echo -e "$green[EFA]$clean Non spam signatures $green DISABLED $clean"
        spamcheck=0
      elif [[ "$TMPNSPAMSIG" == "" || "$TMPNSPAMSIG" == "N" || "$TMPNSPAMSIG" == "n" ]]; then 
        NSPAMSIG="custom(nonspam)"
        echo -e "$green[EFA]$clean Non spam signatures $green ENABLED $clean"
        spamcheck=0
      else
          echo -e "       $red ERROR: please make an selection.$clean"
          echo -e -n "$green[EFA]$clean Do you want to $green DISABLE $clean non spam signatures? [y/N]: "
          read TMPSPAMSIG
      fi
  done

  sed -i "/Non Spam Actions =/ c\Non Spam Actions = $STORENSPAM $NSPAMSIG" /etc/MailScanner/MailScanner.conf
  
  service MailScanner reload
  sleep 2
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Configure Spam Behaviour
# +---------------------------------------------------+
function func_ask-spam() {
  func_echo-header

  echo -e ""
  echo -e "$green[EFA]$clean Spam Delivery and Retention Settings:"
  echo -e ""
  echo -e "$green[EFA]$clean By default, EFA stores spam in quarantine"
  echo -e "$green[EFA]$clean and does not deliver it upon receipt."
  echo -e "$green[EFA]$clean You can optionally choose to deliver spam"
  echo -e "$green[EFA]$clean with \"X-Spam-Status: Yes\" in the mail header."
  echo -e "$green[EFA]$clean This is useful with mail servers that have an"
  echo -e "$green[EFA]$clean integrated spam folder."
  echo -e ""
  echo -e -n "$green[EFA]$clean Do you want to $green ENABLE $clean spam delivery? [y/N]: "
  read TMPDELIVERSPAM
  DELIVERSPAM=""
  spamcheck=1
  while [ $spamcheck != "0" ]
    do 
      if [[ "$TMPDELIVERSPAM" == "Y" || "$TMPDELIVERSPAM" == "y" ]]; then 
        # Set spam delivery behavior
        DELIVERSPAM="deliver header \"X-Spam-Status:Yes\""
        echo -e "$green[EFA]$clean Spam delivery $green ENABLED $clean"
        spamcheck=0
        # Set spam delivery behavior
      elif [[ "$TMPDELIVERSPAM" == "" || "$TMPDELIVERSPAM" == "N" || "$TMPDELIVERSPAM" == "n" ]]; then 
        DELIVERSPAM="store"
        echo -e "$green[EFA]$clean Spam delivery $green DISABLED $clean"
        spamcheck=0
      else
          echo -e "       $red ERROR: please make an selection.$clean"
  echo -e -n "$green[EFA]$clean Do you want to $green ENABLE $clean spam delivery? [y/N]: "
          read TMPDELIVERSPAM
      fi
  done

  if [[ $DELIVERSPAM == "store" ]]; then
    echo -e ""
    echo -e "$green[EFA]$clean Spam Notification Settings:"
    echo -e ""
    echo -e "$green[EFA]$clean By default, EFA notifies users of lower scoring"
    echo -e "$green[EFA]$clean spam when spam is stored in quarantine. Users"
    echo -e "$green[EFA]$clean can release the message by clicking the link"
    echo -e "$green[EFA]$clean link in the {Spam Not Delivered} notification."
    echo -e "$green[EFA]$clean You can optionally choose to disable"
    echo -e "$green[EFA]$clean this feature, especially if your users are"
    echo -e "$green[EFA]$clean abusing this feature and causing Spamassassin"
    echo -e "$green[EFA]$clean to autolearn and poison the Bayesian filter."
    echo -e ""
    echo -e -n "$green[EFA]$clean Do you want to $green DISABLE $clean spam notification? [y/N]: "
    read TMPSPAMNOTIFY
    SPAMNOTIFY=""
    spamcheck=1
    while [ $spamcheck != "0" ]
      do 
        if [[ "$TMPSPAMNOTIFY" == "Y" || "$TMPSPAMNOTIFY" == "y" ]]; then 
          # Set spam notification behavior
          SPAMNOTIFY=""
          echo -e "$green[EFA]$clean Spam Notifications $green DISABLED $clean"
          spamcheck=0
        elif [[ "$TMPSPAMNOTIFY" == "" || "$TMPSPAMNOTIFY" == "N" || "$TMPSPAMNOTIFY" == "n" ]]; then 
          SPAMNOTIFY="custom(spam)"
          echo -e "$green[EFA]$clean Spam Notifications $green ENABLED $clean"
          spamcheck=0
        else
          echo -e "       $red ERROR: please make an selection.$clean"
          echo -e -n "$green[EFA]$clean Do you want to $green DISABLE $clean spam notification? [y/N]: "
          read TMPSPAMNOTIFY
        fi
      done
  fi

  sed -i "/^Spam Actions =/ c\Spam Actions = $DELIVERSPAM $SPAMNOTIFY" /etc/MailScanner/MailScanner.conf

  service MailScanner reload
  sleep 2
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Option Mail settings menu
# +---------------------------------------------------+
func_mail-settings(){
  menu=0
  mailmenu=1
  while [ $mailmenu == "1" ]
    do  
      func_echo-header
      echo -e "Mail settings"
      echo ""
      echo -e "1) Outbound mail relay"
      echo -e "2) Outbound smarthost"
      echo -e "3) Admin Email"
      echo -e "4) Transport settings"
      echo -e ""
      echo -e "e) Return to main menu"
      echo -e ""
      echo -e -n "$green[EFA]$clean : "
      local choice
      read choice
      case $choice in
                1) func_outbound-relay;;
                2) func_outbound-smarthost;;  
                3) func_adminemail;;
                4) func_transport-settings;;
                e) menu=1 && return ;;
                *) echo -e "Error \"$choice\" is not an option..." && sleep 2
            esac
    done
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# transport menu
# +---------------------------------------------------+
func_transport-settings(){
  tpmenu=1
  while [ $tpmenu == "1" ]
    do
      TRANSPORTS=`cat /etc/postfix/transport | sed '/^\#/d;/^$/d'`
      func_echo-header
      echo -e ""
      echo -e "Description:"
      echo -e "All mail domains for which this system accepts mail need an destination server."
      echo -e "Below is the list of current mail domains on this system."
      echo -e ""
      RELAYS=( `cat /etc/postfix/transport | sed '/^\#/d;/^$/d;s/smtp:\[//;s/\]//'` )
      tLen=${#RELAYS[@]}
      padding="                        "
      for (( y=0; y<$tLen; y+=2 ));
      do
        echo -e "$((y/2+1))) ${RELAYS[$y]} ${padding:${#RELAYS[$y]}} ${RELAYS[$((y+1))]}"
      done
      echo -e ""
      echo -e "n) Add new mail domain"
      echo -e ""
      echo -e "e) Return to main menu"
      echo -e ""
      echo -e -n "$green[EFA]$clean : "
      local choice
      read choice
      case $choice in
             [0-9]*)
               if [[ $choice > "0" && $choice < $((tLen/2+1)) ]]; then
                 ENTDOMAIN=${RELAYS[$((choice*2-2))]}
                 ENTDEST=${RELAYS[$((choice*2-1))]}
                 echo -e "Entry Selected: $ENTDOMAIN  $ENTDEST" 
                 flag=0
                 while [ $flag == "0" ]
                   do
                     echo -e ""
                     echo -e "Do you want to $green[r]$clean replace, $green[d]$clean delete this entry, or $green[c]$clean cancel? : "
                     local TMPOPTION
                     read TMPOPTION
                     if [[ $TMPOPTION == "r" || $TMPOPTION == "R" ]]; then
                        echo -e ""
                        echo -e "Please enter the domain you want use:"
                        echo -e -n "$green[Domain]$clean : "
                        local DOMAIN
                        read DOMAIN
                        # Simple check if domain is valid.
                        DOMAINCHECK=1
                        while [ $DOMAINCHECK != 0 ]
                          do
                            if [[ $DOMAIN =~ ^[a-zA-Z0-9]+([\-\.]{1}[a-zA-Z0-9]+)*\.[a-z]{2,6}$ ]]; then
                              DOMAINCHECK=0
                            else
                              echo -e "       $red ERROR: The domain $DOMAINNAME seems to be invalid"
                              echo -e "        ERROR: please re-enter the domain$clean"
                              echo -e ""
                              echo -e -n "$green[Domain]$clean : "
                              read DOMAIN
                            fi
                          done
                        echo -e "Thank you..."
                        echo -e ""
                        echo -e "Now enter the destination server"
                        echo -e -n "$green[Destination]$clean : "
                        local DEST
                        read DEST
                        # Simple check if destination contains any data.
                        DESTCHECK=1
                        while [ $DESTCHECK != 0 ]
                        do
                          if checkip $DEST
                            then
                              # If $DEST looks to be an valid IP we are ok.
                              DESTCHECK=0
                            elif [[ $DEST =~ ^[a-zA-Z0-9]+([\-\.]{1}[a-zA-Z0-9]+)*\.[a-z]{2,6}$ ]]; then
                              # If $DEST looks like an valid domain name we are ok.
                              DESTCHECK=0
                            else
                              echo -e "       $red ERROR: The value $DEST seems to be invalid"
                              echo -e "        ERROR: please re-enter the destination$clean"
                              echo -e ""
                              echo -e -n "$green[Destination]$clean : "
                              read DEST
                          fi
                        done
                        echo -e "Thank you.."
                        sed -i "/$ENTDOMAIN[[:space:]]\+smtp:\[$ENTDEST\]/ c\\$DOMAIN  smtp:[$DEST]" /etc/postfix/transport
                        flag=1
                      elif [[ $TMPOPTION == "d" || $TMPOPTION == "D" ]]; then
                        sed -i "/$ENTDOMAIN[[:space:]]\+smtp:\[$ENTDEST\]/d" /etc/postfix/transport
                        echo -e "Entry deleted from transports." && sleep 2
                        flag=1
                      elif [[ $TMPOPTION == "c" || $TMPOPTION == "C" ]]; then
                        flag=1
                      else 
                        echo -e "Error \"$TMPOPTION\" is not an option..." && sleep 2
                      fi
                    done
                  else
                        echo -e "Error \"$choice\" is not an option..." && sleep 2
                  fi
                    ;;
                n)  echo -e ""
                    echo -e "Please enter the domain you want add:"
                    echo -e -n "$green[Domain]$clean : "
                    local DOMAIN
                    read DOMAIN
                    # Check if the domain is valid.
                    DOMAINCHECK=1
                    while [ $DOMAINCHECK != 0 ]
                      do
                        if [[ $DOMAIN =~ ^[a-zA-Z0-9]+([\-\.]{1}[a-zA-Z0-9]+)*\.[a-z]{2,6}$ ]]; then
                          DOMAINCHECK=0
                        else
                          echo -e "       $red ERROR: The domain $DOMAINNAME seems to be invalid"
                          echo -e "        ERROR: please re-enter the domain$clean"
                          echo -e ""
                          echo -e -n "$green[Domain]$clean : "
                          read DOMAIN
                        fi
                      done
                    echo -e "Thank you..."
                    echo -e ""
                    echo -e "Now enter the destination server"
                    echo -e -n "$green[Destination]$clean : "
                    local DEST
                    read DEST
                    # Simple check if destination contains any data.
                    DESTCHECK=1
                    while [ $DESTCHECK != 0 ]
                      do
                        if checkip $DEST
                          then
                            # If $DEST looks to be an valid IP we are ok.
                            DESTCHECK=0
                          elif [[ $DEST =~ ^[a-zA-Z0-9]+([\-\.]{1}[a-zA-Z0-9]+)*\.[a-z]{2,6}$ ]]; then
                            # If $DEST looks like an valid domain name we are ok.
                            DESTCHECK=0
                          else
                            echo -e "       $red ERROR: The value $DEST seems to be invalid"
                            echo -e "        ERROR: please re-enter the destination$clean"
                            echo -e ""
                            echo -e -n "$green[Destination]$clean : "
                            read DEST
                        fi
                      done
                    echo -e "Thank you.."
                    echo -e "$DOMAIN  smtp:[$DEST]" >> /etc/postfix/transport
                    postmap /etc/postfix/transport
                    echo -e "Domain $DOMAIN added to this system"
                    pause
                    entry=1
                    ;;
                e)  mailmenu=1 && return ;;
                *)  echo -e "Error \"$choice\" is not an option..." && sleep 2
                    echo -e -n "$green[EFA]$clean : "
                    ;;
          esac
  done 
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Configure admin email
# +---------------------------------------------------+
func_adminemail(){
  aemenu=1
  ADMINEMAIL="`cat /etc/EFA-Config | grep ADMINEMAIL | sed 's/.*://'`"
  while [ $aemenu == "1" ]
    do
      func_echo-header
      echo -e ""
      echo -e "Description:"
      echo -e "With this option you can change the E.F.A. admin email address."
      echo -e "This address is used for various system alerts and notifications."
      echo -e ""
      echo -e "Current settings are:"
      echo -e "1) Admin email:        $ADMINEMAIL"
      echo -e ""
      echo -e "e) Return to main menu"
      local choice
      read -p "Enter setting you want to change: " choice
      case $choice in
        1) aemenu=0
           echo -e ""
           echo -e "Enter your new admin email address"
           echo -e ""
           read -p "> " ADMINEMAIL
           sed -i "/ADMINEMAIL\:/ c\ADMINEMAIL\:$ADMINEMAIL" /etc/EFA-Config
           aemenu=1
           ;;
        e) mailmenu=1 && return ;;
        *) echo -e "Error \"$choice\" is not an option..." && sleep 2
      esac
    done
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Configure outbound relay
# +---------------------------------------------------+
func_outbound-relay(){
  obmrmenu=1
  while [ $obmrmenu == "1" ]
    do
      RELAYS=`cat /etc/postfix/main.cf | grep "mynetworks = 127.0.0.0/8" | sed 's/^\(.\{24\}\)//'`
      func_echo-header
      echo " "
      echo "Description:"
      echo "With this option you can configure E.F.A."
      echo "to relay outgoing message for your local"
      echo "mail-server or clients."
      echo ""
      echo "Current settings are:"
      echo "1) Hosts:                $RELAYS"
      echo ""
      echo "e) Return to main menu"
      echo ""
      local choice
      read -p "Enter setting you want to change: " choice
      case $choice in
        1)  obmrmenu=0
            echo ""
            echo "Enter your new hosts string below."
            echo "Note: If you already have hosts defined you need to re-enter these."
            echo "      An empty line will remove all hosts."
            echo "      Separate multiple hosts with spaces."
            echo "      Networks can be defined in the format: x.x.x.x/xx"
            echo ""
            read -p "> " RELAYS
            postconf -e mynetworks="127.0.0.0/8 $RELAYS"
            /etc/init.d/postfix reload >>/dev/null
            obmrmenu=1
            ;;
            e) mailmenu=1 && return ;;
        *) echo -e "Error \"$choice\" is not an option..." && sleep 2
      esac
    done
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Configure Outbound smart-host
# +---------------------------------------------------+
func_outbound-smarthost(){
  obshmenu=1
  while [ $obshmenu == "1" ]
    do
      OBSH="`cat /etc/postfix/main.cf |grep "relayhost ="| grep -v "#" | sed 's/.*relayhost = //'`"
      if [ -z "$OBSH" ]
        then
          OBSH="DISABLED"
      fi
      func_echo-header
      echo " "
      echo "Description:"
      echo "With this option you can configure E.F.A."
      echo "to use a external smart-host for outgoing"
      echo "mail. (useful if you also use E.F.A. as"
      echo "an mail-relay)"
      echo ""
      echo "Current settings are:"
      echo "1) Smart-host:                $OBSH"
      echo "2) Disable smart-host"
      echo ""
      echo "e) Return to main menu"
      echo ""
      local choice
      read -p "Enter setting you want to change: " choice
      case $choice in
            1)  obshmenu=0
                echo ""
                read -p "Enter your new smart host: " OBSH
                postconf -e relayhost=$OBSH
                /etc/init.d/postfix reload >>/dev/null
                echo "Smarthost configured"
                pause
                obshmenu=1
                ;;
            2)  obshmenu=0
                echo ""
                echo "Disabling SmartHost"
                postconf -e relayhost=
                /etc/init.d/postfix reload >>/dev/null
                obshmenu=1
                ;;
            e) mailmenu=1 && return ;;
            *) echo -e "Error \"$choice\" is not an option..." && sleep 2
      esac
    done
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Option IP_SETTINGS
# +---------------------------------------------------+
func_ip-settings(){
  menu=0
  ipmenu=1
  while [ $ipmenu == "1" ]
    do
      func_getipsettings
      func_echo-header
      echo -e "Current IP settings for $INTERFACE are:"
      echo -e "1) IP                   :  $IP"
      echo -e "2) Netmask              :  $NM"
      echo -e "3) Gateway              :  $GW"
      echo -e "4) Primary DNS          :  $DNS1"
      echo -e "5) Secondary DNS        :  $DNS2"
      echo -e ""
      echo -e "e) Return to main menu"
      echo -e ""
      echo -e "$red Note: Network will reset when changing values.$clean"
      echo -e ""
      echo -e "Enter setting you want to change"
      echo -e -n "$green[EFA]$clean : "
      local choice
      read choice
      case $choice in
                1)  ipmenu=0
                    echo ""
                    read -p "Enter your new IP: " IP
                    func_setipsettings
                    menu=1
                    ;;
                2)  ipmenu=0
                    echo ""
                    read -p "Enter your new netmask: " NM
                    func_setipsettings
                    menu=1
                    ;;
                3)  ipmenu=0
                    echo ""
                    read -p "Enter your new gateway: " GW
                    func_setipsettings
                    menu=1
                    ;;
                4)         ipmenu=0
                    echo ""
                    read -p "Enter your new primary DNS: " DNS1
                    func_setipsettings
                    menu=1
                    ;;
                5)         ipmenu=0
                    echo ""
                    read -p "Enter your new secondary DNS: " DNS2
                    func_setipsettings
                    menu=1
                    ;;
                e) menu=1 && return ;;
                *) echo -e "Error \"$choice\" is not an option..." && sleep 2
            esac
        done
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Function to enable/disable greylisting
# +---------------------------------------------------+
func_greylisting(){
  func_echo-header
  echo -e "$green[EFA]$clean Enable/Disable greylisting"
  echo -e ""
  echo -e "$green[EFA]$clean Greylisting will temporarily reject any email from a sender it" 
  echo -e "$green[EFA]$clean does not recognize. If the mail is legitimate the originating server"
  echo -e "$green[EFA]$clean will, after a delay, try again and, if sufficient time has elapsed,"
  echo -e "$green[EFA]$clean the email will be accepted."
  echo ""
  echo -e "$green[EFA]$clean This however causes an delay in receiving mail, by default this system"
  echo -e "$green[EFA]$clean is configured to reject any email for 5 minutes."
  echo -e "$green[EFA]$clean Not all admin's like this setup so giving you the option to disable"
  echo -e "$green[EFA]$clean greylisting on this system."
  echo ""
  if [[ -n $(cat /etc/postfix/main.cf | grep "check_policy_service inet:127.0.0.1:2501") ]]
    then
      # DISABLE greylisting
      echo -e "$green[EFA]$clean Greylisting is currently $green ENABLED $clean"
      echo -e -n "$green[EFA]$clean Would you like to $red DISABLE $clean greylisting? [y/N]: "
      read TMPGREY
        if [[ "$TMPGREY" == "Y" || "$TMPGREY" == "y" ]]; then
          postconf -e "smtpd_recipient_restrictions = permit_sasl_authenticated, permit_mynetworks, reject_unauth_destination, reject_non_fqdn_recipient, reject_unknown_recipient_domain, check_recipient_access hash:/etc/postfix/recipient_access" 
          postfix reload 
          service sqlgrey stop 
          chkconfig sqlgrey off

          # disable Greylist menu item
          /bin/cp -f /var/www/html/mailscanner/functions.php.orig /var/www/html/mailscanner/functions.php

          echo -e "$green[EFA]$clean Greylisting $red DISABLED $clean"
          pause
        elif [[ "$TMPGREY" == "" || "$TMPGREY" == "N" || "$TMPGREY" == "n" ]]; then 
          echo -e "$green[EFA]$clean No changes made"
          echo ""
          pause
        else
          echo -e "       $red ERROR: please make an selection.$clean"
          echo -e -n "$green[EFA]$clean Would you like to $red DISABLE $clean greylisting? [y/N]: "
          read TMPGREY
        fi
    else
      # ENABLE Greylisting
      echo -e "$green[EFA]$clean Greylisting is currently $red DISABLED $clean"
      echo -e -n "$green[EFA]$clean Would you like to $green ENABLE $clean greylisting? [y/N]: "
      read TMPGREY
        if [[ "$TMPGREY" == "Y" || "$TMPGREY" == "y" ]]; then
          postconf -e "smtpd_recipient_restrictions = permit_sasl_authenticated, permit_mynetworks, reject_unauth_destination, reject_non_fqdn_recipient, reject_unknown_recipient_domain, check_recipient_access hash:/etc/postfix/recipient_access, check_policy_service inet:127.0.0.1:2501"
          postfix reload 
          service sqlgrey start 
          chkconfig sqlgrey on
          # Enable Greylist menu item
          /bin/cp -f /var/www/html/mailscanner/functions.php.orig /var/www/html/mailscanner/functions.php
          sed -i "/^            \$nav\['docs.php'\] = \"Documentation\";/{N;s/$/\n        \/\/Begin EFA\n        if \(\$_SESSION\['user_type'\] == 'A'\) \{\n            \$nav\['grey.php'\] = \"greylist\";\n        \}\n        \/\/End EFA/}" /var/www/html/mailscanner/functions.php

          echo -e "$green[EFA]$clean Greylisting $green ENABLED $clean"
          pause
        elif [[ "$TMPGREY" == "" || "$TMPGREY" == "N" || "$TMPGREY" == "n" ]]; then 
          echo -e "$green[EFA]$clean No changes made"
          echo ""
          pause
        else
          echo -e "       $red ERROR: please make an selection.$clean"
          echo -e -n "$green[EFA]$clean Would you like to $green ENABLE $clean greylisting? [y/N]: "
          read TMPGREY
        fi
  fi
}
# +---------------------------------------------------+

# +---------------------------------------------------+
function func_autoupdates() {
  func_echo-header
  echo -e "$green[EFA]$clean Auto Updates:"
  echo -e "$green[EFA]$clean With auto updates you can make sure this system is always up to date." 
  echo -e "$green[EFA]$clean by default we $red DISABLE $clean auto updates as it might not match your"
  echo -e "$green[EFA]$clean company update policy."
  echo -e "$green[EFA]$clean If you choose to keep auto updates DISABLED you will receive mails on your"
  echo -e "$green[EFA]$clean admin e-mail account if an update is available"
  echo ""
  echo -e "$green[EFA]$clean Here you can $green ENABLE $clean auto updates for this E.F.A. system."
  echo -e "$green[EFA]$clean This will check every month if there is an update available and if so"
  echo -e "$green[EFA]$clean it will automatically install the update."
  echo ""
  echo -e "$green[EFA]$clean Note: your system might reboot automatically during auto updates."
  echo ""
  AUTOUPDATES="`cat /etc/EFA-Config | grep AUTOUPDATES | sed 's/.*://'`"
  if [[ $AUTOUPDATES == "ENABLED" ]]
    then
      echo -e "$green[EFA]$clean Auto Updates is currently $green ENABLED $clean"
      echo -e -n "$green[EFA]$clean Would you like to $red DISABLE $clean Auto Updates? [y/N]: "
      read TMPUPDATES
        if [[ "$TMPUPDATES" == "Y" || "$TMPUPDATES" == "y" ]]; then
          sed -i "/AUTOUPDATES:/ c\AUTOUPDATES:DISABLED" /etc/EFA-Config
          echo -e "$green[EFA]$clean Auto Updates $red DISABLED $clean"
          pause
        elif [[ "$TMPUPDATES" == "" || "$TMPUPDATES" == "N" || "$TMPUPDATES" == "n" ]]; then 
          echo -e "$green[EFA]$clean No changes made"
          echo ""
          pause
        else
          echo -e "       $red ERROR: please make an selection.$clean"
          echo -e -n "$green[EFA]$clean Would you like to $red DISABLE $clean Auto Updates? [y/N]: "
          read TMPUPDATES
        fi
    else
      echo -e "$green[EFA]$clean Auto Updates is currently $red DISABLED $clean"
      echo -e -n "$green[EFA]$clean Would you like to $green ENABLE $clean Auto Updates? [y/N]: "
      read TMPUPDATES
        if [[ "$TMPUPDATES" == "Y" || "$TMPUPDATES" == "y" ]]; then
          sed -i "/AUTOUPDATES:/ c\AUTOUPDATES:ENABLED" /etc/EFA-Config
          echo -e "$green[EFA]$clean Auto Updates $green ENABLED $clean"
          pause
        elif [[ "$TMPUPDATES" == "" || "$TMPUPDATES" == "N" || "$TMPUPDATES" == "n" ]]; then 
          echo -e "$green[EFA]$clean No changes made"
          echo ""
          pause
        else
          echo -e "       $red ERROR: please make an selection.$clean"
          echo -e -n "$green[EFA]$clean Would you like to $green ENABLE $clean Auto Updates? [y/N]: "
          read TMPUPDATES
        fi
  fi
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Function to set mailscanner threads (other tunables?)
# +---------------------------------------------------+
func_tunables(){
  func_echo-header
  echo -e "$green[EFA]$clean - Configuring System Tunables"
  echo -e ""
  mschildren="`cat /etc/MailScanner/MailScanner.conf | grep -e '^Max Children' | awk -F'=' '{print $2}' | tr -d '[:blank:]'`"
  echo -e "$green[EFA]$clean Mailscanner is currently set to use $mschildren children."
  echo -e "" 
  echo -e -n "$green[EFA]$clean : Mailscanner children (default/min 2, max 10):"
  read MSTHREADS
  mstuning=1
  while [ $mstuning != "0" ]
   do
     if [[ $MSTHREADS = "" ]]
      then
        MSTHREADS=2
     fi
     if [[ $MSTHREADS =~ ^([2-9]|10)$ ]]
      then
        mstuning=0
      else
        echo -e "       $red ERROR: The number of threads $MSTHREADS appears to be invalid."
        echo -e "        ERROR: please re-enter the number of threads.$clean"
        echo -e -n "$green[EFA]$clean Mailscanner children (default/min 2, max 10):"
        read MSTHREADS
     fi
   done

  # Set mailscanner children 
  sed -i "/^Max Children =/ c\Max Children = $MSTHREADS" /etc/MailScanner/MailScanner.conf
  service MailScanner reload 
  echo -e "MailScanner threads reconfigured to use $MSTHREADS children."
  pause

}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Function to set the new IP settings
# +---------------------------------------------------+
func_setipsettings(){
    for ip in $IP $NM $GW $DNS1 $DNS2
        do
            validcheck=1
            while [ $validcheck != "0" ]
                do
                    if checkip $ip
                        then
                            validcheck=0
                        else
                            echo "ERROR: The value $ip seems to be invalid"
                            pause
                            return
                    fi
                done
        done
  # Grab current FQDN
  HOSTNAME="`cat /etc/EFA-Config | grep HOSTNAME | sed 's/.*://'`"
  DOMAINNAME="`cat /etc/EFA-Config | grep DOMAINNAME | sed 's/.*://'`"
    
  # Write new hosts file
  echo "127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4" > /etc/hosts
  echo "$IP   $HOSTNAME.$DOMAINNAME   $HOSTNAME" >> /etc/hosts
        
  # Write resolv file
  echo "nameserver $DNS1" > /etc/resolv.dnsmasq
  echo "nameserver $DNS2" >> /etc/resolv.dnsmasq

  # Set ip settings
  ifdown $INTERFACE
  # Use ipcalc to get the broadcast & network id's
  BROADCAST="`/bin/ipcalc -b $IP $NM`"
  NETWORK="`/bin/ipcalc -n $IP $NM`"
  echo "DEVICE=\"$INTERFACE\"" > /etc/sysconfig/network-scripts/ifcfg-$INTERFACE
  echo "BOOTPROTO=\"none\"" >> /etc/sysconfig/network-scripts/ifcfg-$INTERFACE
  echo "ONBOOT=\"yes\"" >> /etc/sysconfig/network-scripts/ifcfg-$INTERFACE
  echo "$BROADCAST" >> /etc/sysconfig/network-scripts/ifcfg-$INTERFACE
  echo "$NETWORK" >> /etc/sysconfig/network-scripts/ifcfg-$INTERFACE
  echo "NETMASK=\"$NM\"" >> /etc/sysconfig/network-scripts/ifcfg-$INTERFACE
  echo "IPADDR=\"$IP\"" >> /etc/sysconfig/network-scripts/ifcfg-$INTERFACE
  sed -i "/GATEWAY=/ c\GATEWAY=$GW" /etc/sysconfig/network
  ifup $INTERFACE
  
  echo -e "All done"
  pause
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Function to grab the current IP settings.
# +---------------------------------------------------+
function func_getipsettings(){
  nrintf=`cat /proc/net/dev | grep eth | sed 's/:/ /g' | awk {'print $1 '} | wc -l`
  interf=`cat /proc/net/dev | grep eth | sed 's/:/ /g' | awk {'print $1 '}`
  if [ $nrintf -gt 1 ]
    then
      func_echo-header
      echo -e "You seem to have multiple network interfaces"
      echo -e "Please select the interface you want to configure"
      echo -e "The interface names on your machine are:"
      for int in $interf
        do
          echo " - $int"
        done

      echo -e ""
      echo -e "Enter the primary interface name:"
      echo -e ""
      echo -e -n "$green[EFA]$clean : "
      local choice
      read choice
      choice_check=0
      for int in $interf
        do
        if [ $int == $choice ]
          then
            choice_check=1
        fi
        done
         
      # Check if the user typed a interface that exists.
      if [ $choice_check -eq 0 ]
        then
          echo -e "$red [EFA] ERROR, That interface does not exist. $clean"
          sleep 2
          func_getipsettings
          return
      fi
      if [ $choice_check -eq 1 ]
         then
          INTERFACE=$choice
        fi
     else
        INTERFACE=$interf
    fi
    IP="`cat /etc/sysconfig/network-scripts/ifcfg-$INTERFACE | grep IPADDR | sed 's/IPADDR=//;s/"//g'`"
    NM="`cat /etc/sysconfig/network-scripts/ifcfg-$INTERFACE | grep NETMASK | sed 's/NETMASK=//;s/"//g'`"
    GW="`cat /etc/sysconfig/network | grep GATEWAY | sed 's/GATEWAY=//'`"
    DNS1="`cat /etc/resolv.dnsmasq  | grep -v '#' | grep -v 127.0.0.1 | grep nameserver | awk 'NR==1 {print $2}'`"
    DNS2="`cat /etc/resolv.dnsmasq  | grep -v '#' | grep -v 127.0.0.1 | grep nameserver | awk 'NR==2 {print $2}'`"
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Reboot function
# +---------------------------------------------------+
func_reboot() {
  menu=0
  rebootmenu=1
  while [ $rebootmenu == "1" ]
    do
      func_echo-header 
      echo -e "Are you sure you want to reboot this host?"
      echo -e ""
      echo -e "Y)  Yes I am sure"
      echo -e "N)  No no no take me back!"
      echo -e ""
      echo -e -n "$green[EFA]$clean : "
      local choice
      read choice
      case $choice in
                    Y) reboot && exit 0 ;;
                    N) menu=1 && return  ;;
                    n) menu=1 && return  ;;
                    *) echo -e "Error \"$choice\" is not an option..." && sleep 2
      esac
    done
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Halt function
# +---------------------------------------------------+
func_halt() {
  menu=0
  haltmenu=1
  while [ $haltmenu == "1" ]
    do
      func_echo-header 
      echo -e "Are you sure you want to halt this host?"
      echo -e ""
      echo -e "Y)  Yes I am sure"
      echo -e "N)  No no no take me back!"
      echo -e ""
      echo -e -n "$green[EFA]$clean : "
      local choice
      read choice
      case $choice in
                    Y) shutdown -h now && exit 0 ;;
                    N) menu=1 && return  ;;
                    n) menu=1 && return  ;;
                    *) echo -e "Error \"$choice\" is not an option..." && sleep 2
      esac
    done
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Function to test IP addresses
# +---------------------------------------------------+
function checkip(){
  local ip=$1
  local stat=1

  if [[ $ip =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
        OIFS=$IFS
        IFS='.'
        ip=($ip)
        IFS=$OIFS
        [[ ${ip[0]} -le 255 && ${ip[1]} -le 255 && ${ip[2]} -le 255 && ${ip[3]} -le 255 ]]
        stat=$?
  fi
  return $stat
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Trap CTRL+C, CTRL+Z and quit singles
# +---------------------------------------------------+
trap '' SIGINT SIGQUIT SIGTSTP
# +---------------------------------------------------+

# +---------------------------------------------------+
# Pause
# +---------------------------------------------------+
pause(){
  read -p "Press [Enter] key to continue..." fackEnterKey
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Menu header
# +---------------------------------------------------+
func_echo-header(){
  clear
  echo -e "--------------------------------------------------------------"
  echo -e "---        Welcome to the EFA Configuration program        ---"
  echo -e "---                http://www.efa-project.org              ---"
  echo -e "--------------------------------------------------------------"
  echo ""
}
# +---------------------------------------------------+

# +---------------------------------------------------+
# Main logic
# +---------------------------------------------------+
clear
red='\E[00;31m'
green='\E[00;32m'
yellow='\E[00;33m'
blue='\E[00;34m'
magenta='\E[00;35'
cyan='\E[00;36m'
clean='\e[00m'

if [ `whoami` == root ]
    then
        menu="1"
        while [ $menu == "1" ]
        do
            show_menu
        done
    else
        echo -e "$red [EFA] ERROR: Please become root.$clean"
        exit 0
    fi
# +---------------------------------------------------+
